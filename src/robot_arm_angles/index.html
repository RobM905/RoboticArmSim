<!DOCTYPE html>
<html lang="en">
<head>

<script src="lib/jquery-1.8.3.min.js"></script>
<script src="lib/three.min.js"></script>
<script src="lib/Detector.js"></script>
<script src="lib/Coordinates.js"></script>
<script src="lib/OrbitControls.js"></script>
<script src="lib/TrackballControls.js"></script> -->
 <!-- <script src="lib/uclass_shaders.js"></script> -->
<script src="lib/stats.min.js"></script>
<script src="lib/dat.gui.min.js"></script>
<script src="lib/tween.min.js"></script>
<script src="lib/sprintf.js"></script>


<div id="container"> </div>
<form id="jsonFile" name="jsonFile" enctype="multipart/form-data" method="post">

  <fieldset>
    <h2>Json File</h2>
     <input type='file' id='fileinput'>
     <input type='button' id='btnLoad' value='Load' onclick='loadFile();'>
  </fieldset>
</form>

<script>

function loadFile() {
	 var input, file, fr;

	 if (typeof window.FileReader !== 'function') {
		 alert("The file API isn't supported on this browser yet.");
		 return;
	 }

	 input = document.getElementById('fileinput');
	 if (!input) {
		 alert("Um, couldn't find the fileinput element.");
	 }
	 else if (!input.files) {
		 alert("This browser doesn't seem to support the `files` property of file inputs.");
	 }
	 else if (!input.files[0]) {
		 alert("Please select a file before clicking 'Load'");
	 }
	 else {
		 file = input.files[0];
		 fr = new FileReader();
		 fr.onload = receivedText;
		 fr.readAsText(file);
	 }

	 function receivedText(e) {
		 lines = e.target.result;
		 var newArr = JSON.parse(lines);
		 console.log(newArr);
	 }
 }


var camera, scene, renderer;
var cameraControls, effectController;
var clock = new THREE.Clock();
var gridX = true;
var gridY = false;
var gridZ = false;
var axes = true;
var ground = true;
var arm, forearm, body, effector;
function fillScene() {
		scene = new THREE.Scene();
		//scene.fog = new THREE.Fog(0x808080,2000,4000);
		var ambientLight = new THREE.AmbientLight(0x222222);
		var light = new THREE.DirectionalLight(0xFFFFFF,1.0);
		light.position.set(200, 400, 500);
		var light2 = new THREE.DirectionalLight(0xFFFFFF,1.0);
		light2.position.set(-500, 250, -200);
		scene.add(ambientLight);
		scene.add(light);
		scene.add(light2);
		var robotBaseMaterial = new THREE.MeshPhongMaterial({
				color: 0x6E23BB,
				specular: 0x6E23BB,
				shininess: 20
		});
		var robotForearmMaterial = new THREE.MeshPhongMaterial({
				color: 0xF4C154,
				specular: 0xF4C154,
				shininess: 100
		});
		var robotUpperArmMaterial = new THREE.MeshPhongMaterial({
				color: 0x95E4FB,
				specular: 0x95E4FB,
				shininess: 100
		});
		var robotBodyMaterial = new THREE.MeshPhongMaterial({
				color: 0x279933,
				specular: 0x279933,
				shininess: 100
		});
		var base = new THREE.Mesh(new THREE.CylinderGeometry(30,30,10,32),robotBaseMaterial);
		//base.rotation.x = 90 * Math.PI / 180;
		base.position.y =5;
		scene.add(base);
		forearm = new THREE.Object3D();
		var faLength = 100;
		createRobotExtender(forearm, faLength, robotForearmMaterial);
		arm = new THREE.Object3D();
		var uaLength = 100;
		var eLength = 50;
		effector = new THREE.Object3D();
		createRobotExtender(effector, eLength, robotForearmMaterial);
		arm = new THREE.Object3D();
		createRobotCrane(arm, uaLength, robotUpperArmMaterial);
		endEffector = new THREE.Object3D();
		createEndEffector(endEffector, robotUpperArmMaterial);
		forearm.position.y = uaLength;
		effector.position.y = faLength;
		endEffector.position.y = eLength;
		effector.add(endEffector);
		forearm.add(effector);
		arm.add(forearm);
		arm.position.y = arm.position.y + 10;
		scene.add(arm);

}
function createRobotExtender(part, length, material) {
		// var cylinder = new THREE.Mesh(new THREE.CylinderGeometry(22,22,6,32),material);
		// part.add(cylinder);
		var i;
		for (i = 0; i < 4; i++) {
				var box = new THREE.Mesh(new THREE.CubeGeometry(4,length,4),material);
				box.position.x = (i < 2) ? -8 : 8;
				box.position.y = length / 2;
				box.position.z = (i % 2) ? -8 : 8;
				part.add(box);
		}
		cylinder = new THREE.Mesh(new THREE.CylinderGeometry(15,15,40,32),material);
		cylinder.rotation.x = 90 * Math.PI / 180;
		cylinder.position.y = 0;
		part.add(cylinder);
}
function createRobotCrane(part, length, material) {
		var box = new THREE.Mesh(new THREE.CubeGeometry(18,length,18),material);
		box.position.y = length / 2;
		part.add(box);


	cylinder1 = new THREE.Mesh(new THREE.CylinderGeometry(15,15,40,32),material);
		cylinder1.rotation.x = 90 * Math.PI / 180;
		cylinder1.position.y = 0;
		part.add(cylinder1);
		// var sphere = new THREE.Mesh(new THREE.SphereGeometry(20,32,16),material);
		// sphere.position.y = length;
		// part.add(sphere);
}
function createRobotBody(part, length, material) {
		var cylinder = new THREE.Mesh(new THREE.CylinderGeometry(50,12,length / 2,18),material);
		cylinder.position.y = length / 4;
		part.add(cylinder);
		cylinder = new THREE.Mesh(new THREE.CylinderGeometry(12,50,length / 2,18),material);
		cylinder.position.y = 3 * length / 4;
		part.add(cylinder);
		var box = new THREE.Mesh(new THREE.CubeGeometry(12,length / 4,110),material);
		box.position.y = length / 2;
		part.add(box);
		//var sphere = new THREE.Mesh(new THREE.SphereGeometry(20,32,16),material);
		//sphere.position.y = length;6
		//part.add(sphere);
}
function createEndEffector(part, material){
		var cylinder = new THREE.Mesh(new THREE.CylinderGeometry(15,15,10,32),material);
		cylinder.position.y = 0;
		part.add(cylinder);
		var cone = new THREE.Mesh(new THREE.ConeGeometry( 15, 30, 32 ),new THREE.MeshPhongMaterial({
				color: 0x6E23BB,
				specular: 0x6E23BB,
				shininess: 20
		}));
		cone.position.y = 15;
		part.add(cone);
}
function init() {


		container = document.getElementById( 'container' );
		var canvasWidth = 846;
		var canvasHeight = 494;
		var canvasRatio = canvasWidth / canvasHeight;
		renderer = new THREE.WebGLRenderer({
				antialias: true,
				alpha: true
		});
		renderer.gammaInput = true;
		renderer.gammaOutput = true;
		renderer.setSize(canvasWidth, canvasHeight);
		renderer.setClearColor(0x000000, 0 );
		camera = new THREE.PerspectiveCamera(38,canvasRatio,1,10000);
		camera.position.set(-510, 240, 100);
		cameraControls = new THREE.OrbitControls(camera,renderer.domElement);
		cameraControls.target.set(0, 120, 0);
		camera.position.set(-102, 177, 20);
		cameraControls.target.set(-13, 60, 2);
		//var tween = new TWEEN.Tween(rotation).to(10* Math.PI / 180 , 2000);
		fillScene();
}
function addToDOM() {
		var container = document.getElementById('container');
		var canvas = container.getElementsByTagName('canvas');
		if (canvas.length > 0) {
				container.removeChild(canvas[0]);
		}
		container.appendChild(renderer.domElement);
}
function drawHelpers() {
		if (ground) {
				Coordinates.drawGround({
						size: 10000
				});
		}
		if (gridX) {
				Coordinates.drawGrid({
						size: 10000,
						scale: 0.01
				});
		}
		if (gridY) {
				Coordinates.drawGrid({
						size: 10000,
						scale: 0.01,
						orientation: "y"
				});
		}
		if (gridZ) {
				Coordinates.drawGrid({
						size: 10000,
						scale: 0.01,
						orientation: "z"
				});
		}
		if (axes) {
				Coordinates.drawAllAxes({
						axisLength: 200,
						axisRadius: 1,
						axisTess: 50
				});
		}
}
function animate() {
		window.requestAnimationFrame(animate);
		render();
}
function render() {
		var delta = clock.getDelta();
		cameraControls.update(delta);
		if (effectController.newGridX !== gridX || effectController.newGridY !== gridY || effectController.newGridZ !== gridZ || effectController.newGround !== ground || effectController.newAxes !== axes) {
				gridX = effectController.newGridX;
				gridY = effectController.newGridY;
				gridZ = effectController.newGridZ;
				ground = effectController.newGround;
				axes = effectController.newAxes;
				fillScene();
				drawHelpers();
		}

		// rotateAngle(arm, y, effectController.uy);
		// rotateAngle(arm, z, effectController.uz* Math.PI / 180);
		// rotateAngle(effector, z, effectController.ez* Math.PI / 180);
		// rotateAngle(forearm, z, effectController.fz* Math.PI / 180);
		arm.rotation.y = effectController.uy * Math.PI / 180;
		// if(arm.rotation.y != effectController.uy){
		// 		console.log(arm.rotation.y);
		// }
		arm.rotation.z = effectController.uz * Math.PI / 180;
		effector.rotation.z = effectController.ez * Math.PI / 180;
		forearm.rotation.z = effectController.fz * Math.PI / 180;
		renderer.render(scene, camera);
}

// function rotateAngle(part, axis, destAngle){
// 	var destAngleDeg = destAngle* Math.PI / 180;
//
// 	//console.log(destAngle);
// 	// console.log(arm.rotation.y);
// 	// console.log(destAngle);
// 	if(arm.rotation.y != destAngleDeg){
// 		if(arm.rotation.y < destAngleDeg){
// 			arm.rotation.y = arm.rotation.y + 0.001;
// 		}
// 		else if (arm.rotation.y > destAngleDeg) {
// 			arm.rotation.y = arm.rotation.y - 0.001;
// 		}
// 	}
//
//
// }
function setupGui() {
		effectController = {
				newGridX: gridX,
				newGridY: gridY,
				newGridZ: gridZ,
				newGround: ground,
				newAxes: axes,
				uy: 0.0,
				uz: 0.0,
				ez: 0.0,
				fz: 0.0
		};
		var gui = new dat.GUI();
		var h = gui.addFolder("Grid display");
		h.add(effectController, "newGridX").name("Show XZ grid");
		h.add(effectController, "newGridY").name("Show YZ grid");
		h.add(effectController, "newGridZ").name("Show XY grid");
		h.add(effectController, "newGround").name("Show ground");
		h.add(effectController, "newAxes").name("Show axes");
		h = gui.addFolder("Arm angles");
		h.add(effectController, "uy", -180.0, 180.0, 0.025).name("Upper arm y").onChange(function(uy){console.log(uy)});
		h.add(effectController, "uz", -45.0, 45.0, 0.025).name("Upper arm z").onChange(function(uz){console.log(uz)});
		h.add(effectController, "fz", -120.0, 120.0, 0.025).name("Forearm z").onChange(function(fz){console.log(fz)});
		h.add(effectController, "ez", -120.0, 120.0, 0.025).name("Effector z").onChange(function(ez){console.log(ez)});
}
try {
		init();
		fillScene();
		drawHelpers();
		addToDOM();
		setupGui();
		animate();
} catch (e) {
		var errorReport = "Your program encountered an unrecoverable error, can not draw on canvas. Error was:<br/><br/>";
		$('#container').append(errorReport + e);
}



		</script>
</head>
<body>
>

</body>
</html>
