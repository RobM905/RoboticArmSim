<!DOCTYPE html>
<html lang="en">
<head>

<script src="lib/jquery-1.8.3.min.js"></script>
<script src="lib/three.min.js"></script>
<script src="lib/three-old.min.js"></script>
<!-- <script src="lib/Detector.js"></script> -->
<script src="lib/Coordinates.js"></script>
<script src="lib/OrbitControls.js"></script>
<script src="lib/OrbitAndPanControls.js"></script>
<script src="lib/kinematics.js"></script>
<!-- <script src="lib/TrackballControls.js"></script> -->
 <!-- <script src="lib/uclass_shaders.js"></script> -->
<script src="lib/stats.min.js"></script>
<script src="lib/dat.gui.js"></script>
<script src="lib/tween.min.js"></script>
<!-- <script src="lib/sprintf.js"></script> -->
<link rel="stylesheet" type="text/css" href="css/index.css">


<div id="controls">
<form id="jsonFile" name="jsonFile" method="post">
  <fieldset>
    <h2>Import File</h2>
     <input type='file' id='fileinput'>
     <input type='button' id='btnLoad' value='Load' onclick='loadFile(createNewArm);'>
  </fieldset>
</form>
</div>
<div id="container"> </div>
<script>

function loadFile(callback) {
	 var input, file, fr;

	 if (typeof window.FileReader !== 'function') {
		 alert("The file API isn't supported on this browser yet.");
		 return;
	 }

	 input = document.getElementById('fileinput');
	 if (!input) {
		 alert("Um, couldn't find the fileinput element.");
	 }
	 else if (!input.files) {
		 alert("This browser doesn't seem to support the `files` property of file inputs.");
	 }
	 else if (!input.files[0]) {
		 alert("Please select a file before clicking 'Load'");
	 }
	 else {
		 file = input.files[0];
		 fr = new FileReader();
		 fr.onload = function (e){
       result = e.target.result;
  		  var JsonArray = JSON.parse(result);
        callback(JsonArray);
     };
	   fr.readAsText(file);
	 }


 }


var camera, scene, renderer;
var cameraControls, effectController;
var clock = new THREE.Clock();
var gridX = true;
var gridY = false;
var gridZ = false;
var axes = true;
var ground = true;
var arm, forearm, body, effector;
var gui;
//const Kinematics = require('kinematics').default;

function forwardKinematics(arm){
  var jointHeights = [];
  var jointAngles = [];
  var e = 0;
  var h = 0;
  var armR = 0;
  var angleSum = 0;
  var x = 0;
  var y = 0;

  arm.forEach(function(object){
  //  console.log(object);
    if(object['type']!='effector'){
      jointHeights.push(object['length']);
      jointAngles.push(object['angle']* Math.PI / 180);
      console.log(object['object'].rotation);
      }
      else{
        scene.updateMatrixWorld();
        var worldPos  = new THREE.Vector3().getPositionFromMatrix(object['object'].matrixWorld);

        console.log('effect location from three.js');
        console.log(worldPos);
      }

  })
  console.log('jointHeights\n');
  console.log(jointHeights);
  console.log('jointAngles\n');
  console.log(jointAngles);
    h = jointHeights[0];
    armR = jointAngles[0];

  for (i=1; i<4; i++){
      angleSum += jointAngles[i];
      var tempHeight = jointHeights[i] * Math.cos(  angleSum ).toFixed(15);
      console.log(tempHeight);
      var tempExtent = jointHeights[i] * Math.sin(  angleSum );
      console.log(tempExtent);
      h += tempHeight;
      e += tempExtent;
    }
    x = e * Math.sin(jointAngles[1]);
    y = e * Math.cos(jointAngles[1]).toFixed(15);
    console.log(h);
    console.log(e);
    console.log('effect location from kinematics');
    console.log(x,y,h);

  }
      // if(object['type']=='crane'){
      //   console.log(object['type']);
      //   console.log(object['angle']);
      //   console.log(object['length']);
      // }
      // else if(object['type']=='extender')
      //     console.log(object['type']);
      //     console.log(object['angle']);
      //     console.log(object['length']);
      //

      // scene.updateMatrixWorld();
      // var vector = new THREE.Vector3();
      // vector.setFromMatrixPosition(object['object'].matrixWorld );
    //  console.log(object['object']['position']);
      //console.log(object['object']['rotation']);

    //console.log(Math.cos(90 * Math.PI / 180));
    //var h = (object["length"] * (Math.sin(object["angle"] * Math.PI / 180)));
    //console.log(h);
    //height += h;
    //var e = (object["length"] * (Math.cos(object["angle"] * Math.PI / 180)));
    //extent += e;

    //console.log("z: ");
    //console.log(height);
    //console.log("extent: ");
    //console.log(e);









function createNewArm(armConfig){
  // console.log(scene);
  while (scene.children.length)
    {
    scene.remove(scene.children[0]);
    }

    var ambientLight = new THREE.AmbientLight(0x222222);
		var light = new THREE.DirectionalLight(0xFFFFFF,1.0);
		light.position.set(200, 400, 500);
		var light2 = new THREE.DirectionalLight(0xFFFFFF,1.0);
		light2.position.set(-500, 250, -200);
		scene.add(ambientLight);
		scene.add(light);
		scene.add(light2);
		var robotBaseMaterial = new THREE.MeshPhongMaterial({
				color: 0x6E23BB,
				specular: 0x6E23BB,
				shininess: 20
		});
		var robotForearmMaterial = new THREE.MeshPhongMaterial({
				color: 0xF4C154,
				specular: 0xF4C154,
				shininess: 100
		});
		var robotUpperArmMaterial = new THREE.MeshPhongMaterial({
				color: 0x95E4FB,
				specular: 0x95E4FB,
				shininess: 100
		});
		var robotBodyMaterial = new THREE.MeshPhongMaterial({
				color: 0x279933,
				specular: 0x279933,
				shininess: 100
		});


    var upper_bound = 400;
    var lower_bound = 10;
    for (i=0;i<5;i++ ){
      var rockgeometry = new THREE.SphereGeometry(20, 6, 4);
      var rock =  new THREE.Mesh(rockgeometry, robotBaseMaterial);
      rock.position.y = 5;
      var z = Math.round(Math.random()*(upper_bound) - lower_bound);
      var x = Math.round(Math.random()*(upper_bound) - lower_bound);
      rock.position.z = z;
      rock.position.x = x;
      scene.add(rock);

    }
		var base = new THREE.Mesh(new THREE.CylinderGeometry(30,30,10,32),robotBaseMaterial);

		base.position.y =5;
		scene.add(base);
    drawHelpers();

    arm = new THREE.Object3D();
    for (x in armConfig['arm']) {

      armConfig['arm'][x]["tween"] = {tween:{},status:false};


    var tempArm = new THREE.Object3D();

    var length = armConfig['arm'][x]['length'];
    if(armConfig['arm'][x]['type'] == 'crane'){
      createRobotCrane(tempArm, length, robotUpperArmMaterial);
      armConfig['arm'][x]['object'] = tempArm;

    }
    else if(armConfig['arm'][x]['type'] == 'extender'){
      createRobotExtender(tempArm, length, robotForearmMaterial);
      armConfig['arm'][x]['object'] = tempArm;

    }
    else if(armConfig['arm'][x]['type'] == 'effector'){
      createEndEffector(tempArm,  robotUpperArmMaterial)
      armConfig['arm'][x]['object'] = tempArm;

    }


}

  for (var i = armConfig['arm'].length-1; i != -1; --i) {
    //console.log(i);
    if(i != 0){
      var armObject = armConfig['arm'][i]['object'];
      armObject.position.y = armConfig['arm'][i-1]['length'];
      armConfig['arm'][i-1]['object'].add(armObject);
    }
    else{
      arm.add(armConfig['arm'][i]['object']);
    }
        //console.log(armObject);
  }
  scene.add(arm);
  remakeGUI(armConfig['arm']);



  }
function fillScene() {
		scene = new THREE.Scene();
		var ambientLight = new THREE.AmbientLight(0x222222);
		var light = new THREE.DirectionalLight(0xFFFFFF,1.0);
		light.position.set(200, 400, 500);
		var light2 = new THREE.DirectionalLight(0xFFFFFF,1.0);
		light2.position.set(-500, 250, -200);
		scene.add(ambientLight);
		scene.add(light);
		scene.add(light2);
		var robotBaseMaterial = new THREE.MeshPhongMaterial({
				color: 0x6E23BB,
				specular: 0x6E23BB,
				shininess: 20
		});
		var robotForearmMaterial = new THREE.MeshPhongMaterial({
				color: 0xF4C154,
				specular: 0xF4C154,
				shininess: 100
		});
		var robotUpperArmMaterial = new THREE.MeshPhongMaterial({
				color: 0x95E4FB,
				specular: 0x95E4FB,
				shininess: 100
		});
		var robotBodyMaterial = new THREE.MeshPhongMaterial({
				color: 0x279933,
				specular: 0x279933,
				shininess: 100
		});
    var upper_bound = 400;
    var lower_bound = 10;
    for (i=0;i<5;i++ ){
      var rockgeometry = new THREE.SphereGeometry(20, 6, 4);
      var rock =  new THREE.Mesh(rockgeometry, robotBaseMaterial);
      rock.position.y = 5;
      rock.position.z = Math.round(Math.random()*(upper_bound) - lower_bound);
      rock.position.x = Math.round(Math.random()*(upper_bound) - lower_bound);
      scene.add(rock);

    }


		var base = new THREE.Mesh(new THREE.CylinderGeometry(30,30,10,32),robotBaseMaterial);

		base.position.y =5;
		scene.add(base);
		forearm = new THREE.Object3D();
		var faLength = 100;
		createRobotExtender(forearm, faLength, robotForearmMaterial);
		var uaLength = 100;
		var eLength = 50;
		effector = new THREE.Object3D();
		createRobotExtender(effector, eLength, robotForearmMaterial);
		arm = new THREE.Object3D();

		createRobotCrane(arm, uaLength, robotUpperArmMaterial);
		endEffector = new THREE.Object3D();
		createEndEffector(endEffector, robotUpperArmMaterial);
		forearm.position.y = uaLength;
		effector.position.y = faLength;
		endEffector.position.y = eLength;
		effector.add(endEffector);
		forearm.add(effector);
		arm.add(forearm);
		//arm.position.y = arm.position.y + 10;
		scene.add(arm);

}
function createRobotExtender(part, length, material) {
		var i;
		for (i = 0; i < 4; i++) {
				var box = new THREE.Mesh(new THREE.CubeGeometry(4,length,4),material);
				box.position.x = (i < 2) ? -8 : 8;
				box.position.y = length / 2;
				box.position.z = (i % 2) ? -8 : 8;
				part.add(box);
		}
		cylinder = new THREE.Mesh(new THREE.CylinderGeometry(15,15,40,32),material);
		cylinder.rotation.x = 90 * Math.PI / 180;
		cylinder.position.y = 0;
		part.add(cylinder);
}
function createRobotCrane(part, length, material) {
		var box = new THREE.Mesh(new THREE.CubeGeometry(18,length,18),material);
		box.position.y = length / 2;
		part.add(box);


	cylinder1 = new THREE.Mesh(new THREE.CylinderGeometry(15,15,40,32),material);
		cylinder1.rotation.x = 90 * Math.PI / 180;
		cylinder1.position.y = 0;
		part.add(cylinder1);
		// var sphere = new THREE.Mesh(new THREE.SphereGeometry(20,32,16),material);
		// sphere.position.y = length;
		// part.add(sphere);
}
function createRobotBody(part, length, material) {
		var cylinder = new THREE.Mesh(new THREE.CylinderGeometry(50,12,length / 2,18),material);
		cylinder.position.y = length / 4;
		part.add(cylinder);
		cylinder = new THREE.Mesh(new THREE.CylinderGeometry(12,50,length / 2,18),material);
		cylinder.position.y = 3 * length / 4;
		part.add(cylinder);
		var box = new THREE.Mesh(new THREE.CubeGeometry(12,length / 4,110),material);
		box.position.y = length / 2;
		part.add(box);
		//var sphere = new THREE.Mesh(new THREE.SphereGeometry(20,32,16),material);
		//sphere.position.y = length;6
		//part.add(sphere);
}
function createEndEffector(part, material){
		var cylinder = new THREE.Mesh(new THREE.CylinderGeometry(15,15,10,32),material);
		cylinder.position.y = 0;
		part.add(cylinder);
    var finger = new THREE.Mesh(new THREE.CubeGeometry(10,20,10,4),material);
		finger.position.y = 10;
		part.add(finger);
		var cone = new THREE.Mesh(new THREE.ConeGeometry( 15, 30, 32 ),new THREE.MeshPhongMaterial({
				color: 0x6E23BB,
				specular: 0x6E23BB,
				shininess: 20
		}));
		cone.position.y = 15;
		part.add(cone);
}
function init() {


		container = document.getElementById( 'container' );

		var canvasWidth = $(container).width();
		var canvasHeight = $(container).height();
		var canvasRatio = canvasWidth / canvasHeight;
		renderer = new THREE.WebGLRenderer({
				antialias: true,
				alpha: true
		});
		renderer.gammaInput = true;
		renderer.gammaOutput = true;
		renderer.setSize(canvasWidth, canvasHeight);
		renderer.setClearColor(0x000000, 0 );
		camera = new THREE.PerspectiveCamera(38,canvasRatio,1,10000);
		camera.position.set(-510, 240, 100);
		 //cameraControls = new THREE.OrbitControls(camera,renderer.domElement);
    cameraControls = new THREE.OrbitAndPanControls(camera,renderer.domElement);
		cameraControls.target.set(0, 120, 0);
		camera.position.set(-102, 177, 20);
		cameraControls.target.set(-13, 60, 2);

		fillScene();
}
function addToDOM() {
		var container = document.getElementById('container');
		var canvas = container.getElementsByTagName('canvas');
		if (canvas.length > 0) {
				container.removeChild(canvas[0]);
		}
		container.appendChild(renderer.domElement);
    console.log(renderer.domElement);
}
function drawHelpers() {
		if (ground) {
				Coordinates.drawGround({
						size: 10000
				});
		}
		if (gridX) {
				Coordinates.drawGrid({
						size: 10000,
						scale: 0.01
				});
		}
		if (gridY) {
				Coordinates.drawGrid({
						size: 10000,
						scale: 0.01,
						orientation: "y"
				});
		}
		if (gridZ) {
				Coordinates.drawGrid({
						size: 10000,
						scale: 0.01,
						orientation: "z"
				});
		}
		if (axes) {
				Coordinates.drawAllAxes({
						axisLength: 200,
						axisRadius: 1,
						axisTess: 50
				});
		}
}
function animate() {
		window.requestAnimationFrame(animate);
    TWEEN.update();
		render();
}
function render() {
		var delta = clock.getDelta();
		cameraControls.update(delta);
		if (effectController.newGridX !== gridX || effectController.newGridY !== gridY || effectController.newGridZ !== gridZ || effectController.newGround !== ground || effectController.newAxes !== axes) {
				gridX = effectController.newGridX;
				gridY = effectController.newGridY;
				gridZ = effectController.newGridZ;
				ground = effectController.newGround;
				axes = effectController.newAxes;
				//fillScene();
				drawHelpers();
		}
		renderer.render(scene, camera);
}

function remakeGUI(armconfig){
  gui.destroy();
  effectController = {
      newGridX: gridX,
      newGridY: gridY,
      newGridZ: gridZ,
      newGround: ground,
      newAxes: axes
  };


  gui = new dat.GUI();
  var h = gui.addFolder("Grid display");
  h.add(effectController, "newGridX").name("Show XZ grid");
  h.add(effectController, "newGridY").name("Show YZ grid");
  h.add(effectController, "newGridZ").name("Show XY grid");
  h.add(effectController, "newGround").name("Show ground");
  h.add(effectController, "newAxes").name("Show axes");
  h = gui.addFolder("Arm angles");
  armconfig.forEach(function(object){
      object["angle"] = 0.0;

      if(object["z"]){
          h.add(object, "angle", 0.0, 360.0, 0.025).name(object["id"] + "z").onChange(function(angle){
            moveArm(object, angle, "z")
          });
      }
      if(object["y"]){
          h.add(object, "angle", 0.0, 360.0, 0.025).name(object["id"] + "y").onChange(function(angle){
            moveArm(object, angle,"y")
          });
      }
      if(object["x"]){
        h.add(object, "angle", 0.0, 360.0, 0.025).name(object["id"] + "x").onChange(function(angle){
          moveArm(object, angle*Math.PI / 4,"x")
        });
      }
  });
  var obj = { Move:function(){  armconfig.forEach(function(object){
      //console.log(object["tween"]);
        console.log(object);
        object["tween"].start();
    })
      forwardKinematics(armconfig);

    }
  };

  gui.add(obj,'Move');

}

function moveArm(armObject, angle, axis){
if(axis == "z"){
  if(!armObject["tween"].status){
  //  armObject["object"].rotation.z = angle * Math.PI / 180;
    //console.log(armObject["tween"]);
    armObject["tween"].status = true;
    armObject["tween"] = new TWEEN.Tween( { z : armObject["object"].rotation.z, obj : armObject["object"], tween : armObject["tween"] } )
      .to( { z : angle * Math.PI / 180 }, 2000 )
      .onUpdate( function () {
        this.obj.rotation.z = this.z;
      } )
      .easing( TWEEN.Easing.Exponential.InOut )
      .onComplete( function () {
        this.tween.status = false;
      });
      //.start();
  }

}
else if(axis == "y"){
  if(!armObject["tween"].status){
  //  armObject["object"].rotation.z = angle * Math.PI / 180;
    console.log(armObject["tween"]);
    armObject["tween"].status = true;
    armObject["tween"] = new TWEEN.Tween( { y : armObject["object"].rotation.y, obj : armObject["object"], tween : armObject["tween"] } )
      .to( { y : angle * Math.PI / 180 }, 2000 )
      .onUpdate( function () {
        this.obj.rotation.y = this.y;
      } )
      .easing( TWEEN.Easing.Exponential.InOut )
      .onComplete( function () {
        this.tween.status = false;
      });
      //.start();
  // armObject["object"].rotation.y = angle * Math.PI / 180;
  // console.log("move in y");
  }
}
else if(axis == "x"){
  if(!armObject["tween"].status){
  //  armObject["object"].rotation.z = angle * Math.PI / 180;
    console.log(armObject["tween"]);
    armObject["tween"].status = true;
    armObject["tween"] = new TWEEN.Tween( { x : armObject["object"].rotation.x, obj : armObject["object"], tween : armObject["tween"] } )
      .to( { x : angle * Math.PI / 180 }, 2000 )
      .onUpdate( function () {
        this.obj.rotation.x = this.x;
      } )
      .easing( TWEEN.Easing.Exponential.InOut )
      .onComplete( function () {
        this.tween.status = false;
      });
      //.start();
  // armObject["object"].rotation.y = angle * Math.PI / 180;
  // console.log("move in y");
  }

  // armObject["object"].rotation.x = angle * Math.PI / 180;
  // console.log("move in x");
}
  console.log(armObject);
}

function setupGui() {
    effectController = {
        newGridX: gridX,
        newGridY: gridY,
        newGridZ: gridZ,
        newGround: ground,
        newAxes: axes

    };
    var obj = { test:function(){ console.log("clicked") }};
    gui = new dat.GUI();
    var h = gui.addFolder("Grid display");
    h.add(effectController, "newGridX").name("Show XZ grid");
    h.add(effectController, "newGridY").name("Show YZ grid");
    h.add(effectController, "newGridZ").name("Show XY grid");
    h.add(effectController, "newGround").name("Show ground");
    h.add(effectController, "newAxes").name("Show axes");
    h = gui.addFolder("Arm angles");
      gui.add(obj,'test');
}

try {
		init();
		fillScene();
		drawHelpers();
		addToDOM();
		setupGui();
		animate();
} catch (e) {
		var errorReport = "Your program encountered an unrecoverable error, can not draw on canvas. Error was:<br/><br/>";
		$('#container').append(errorReport + e);
}



		</script>
</head>
<body>


</body>
</html>
