<!DOCTYPE html>
<html lang="en">
<head>

<script src="lib/jquery-1.8.3.min.js"></script>
<script src="lib/three.min.js"></script>
<script src="lib/Detector.js"></script>
<script src="lib/Coordinates.js"></script>
<script src="lib/OrbitControls.js"></script>
<script src="lib/TrackballControls.js"></script> -->
 <!-- <script src="lib/uclass_shaders.js"></script> -->
<script src="lib/stats.min.js"></script>
<script src="lib/dat.gui.min.js"></script>
<script src="lib/tween.min.js"></script>
<script src="lib/sprintf.js"></script>

<div id="controls"> </div>
<div id="container"> </div>

<form id="jsonFile" name="jsonFile" enctype="multipart/foAjazz AK33rm-data" method="post">
  <fieldset>
    <h2>Import File</h2>
     <input type='file' id='fileinput'>
     <input type='button' id='btnLoad' value='Load' onclick='loadFile(createNewArm);'>
  </fieldset>
</form>

<script>

function loadFile(callback) {
	 var input, file, fr;

	 if (typeof window.FileReader !== 'function') {
		 alert("The file API isn't supported on this browser yet.");
		 return;
	 }

	 input = document.getElementById('fileinput');
	 if (!input) {
		 alert("Um, couldn't find the fileinput element.");
	 }
	 else if (!input.files) {
		 alert("This browser doesn't seem to support the `files` property of file inputs.");
	 }
	 else if (!input.files[0]) {
		 alert("Please select a file before clicking 'Load'");
	 }
	 else {
		 file = input.files[0];
		 fr = new FileReader();
		 fr.onload = function (e){
       result = e.target.result;
  		  var JsonArray = JSON.parse(result);
        callback(JsonArray);
     };
	   fr.readAsText(file);
	 }


 }


var camera, scene, renderer;
var cameraControls, effectController;
var clock = new THREE.Clock();
var gridX = true;
var gridY = false;
var gridZ = false;
var axes = true;
var ground = true;
var arm, forearm, body, effector;
var gui;

function createNewArm(armConfig){
  // console.log(scene);
  while (scene.children.length)
    {
    scene.remove(scene.children[0]);
    }

    var ambientLight = new THREE.AmbientLight(0x222222);
		var light = new THREE.DirectionalLight(0xFFFFFF,1.0);
		light.position.set(200, 400, 500);
		var light2 = new THREE.DirectionalLight(0xFFFFFF,1.0);
		light2.position.set(-500, 250, -200);
		scene.add(ambientLight);
		scene.add(light);
		scene.add(light2);
		var robotBaseMaterial = new THREE.MeshPhongMaterial({
				color: 0x6E23BB,
				specular: 0x6E23BB,
				shininess: 20
		});
		var robotForearmMaterial = new THREE.MeshPhongMaterial({
				color: 0xF4C154,
				specular: 0xF4C154,
				shininess: 100
		});
		var robotUpperArmMaterial = new THREE.MeshPhongMaterial({
				color: 0x95E4FB,
				specular: 0x95E4FB,
				shininess: 100
		});
		var robotBodyMaterial = new THREE.MeshPhongMaterial({
				color: 0x279933,
				specular: 0x279933,
				shininess: 100
		});


		var base = new THREE.Mesh(new THREE.CylinderGeometry(30,30,10,32),robotBaseMaterial);
		//base.rotation.x = 90 * Math.PI / 180;
		base.position.y =5;
		scene.add(base);
    drawHelpers();
  //  console.log(armConfig);
    arm = new THREE.Object3D();
    for (x in armConfig['arm']) {

    //console.log(armConfig['arm'][x]);
    var tempArm = new THREE.Object3D();
    //console.log(tempArm);
    var length = armConfig['arm'][x]['length'];
    if(armConfig['arm'][x]['type'] == 'crane'){
      createRobotCrane(tempArm, length, robotUpperArmMaterial);
      armConfig['arm'][x]['object'] = tempArm;
      //arm.add(tempArm);
    }
    else if(armConfig['arm'][x]['type'] == 'extender'){
      createRobotExtender(tempArm, length, robotForearmMaterial);
      armConfig['arm'][x]['object'] = tempArm;
    //  tempArm.position.y = armConfig['arm'][x-1]['length'];
      //arm.add(tempArm);
    }


}

  for (var i = armConfig['arm'].length-1; i != -1; --i) {
    //console.log(i);
    if(i != 0){
      var armObject = armConfig['arm'][i]['object'];
      armObject.position.y = armConfig['arm'][i-1]['length'];
      armConfig['arm'][i-1]['object'].add(armObject);
    }
    else{
      arm.add(armConfig['arm'][i]['object']);
    }
        //console.log(armObject);
  }
  scene.add(arm);
  remakeGUI(armConfig['arm']);
  //console.log(armConfig['arm']);
		//  forearm = new THREE.Object3D();
		//  var faLength = 100;
		// createRobotExtender(forearm, faLength, robotForearmMaterial);
		// var uaLength = 100;
		// var eLength = 50;
		// effector = new THREE.Object3D();
		// createRobotExtender(effector, eLength, robotForearmMaterial);
		// arm = new THREE.Object3D();
		// createRobotCrane(arm, uaLength, robotUpperArmMaterial);
		// endEffector = new THREE.Object3D();
		// createEndEffector(endEffector, robotUpperArmMaterial);
		// forearm.position.y = uaLength;
		// effector.position.y = faLength;
		// endEffector.position.y = eLength;
		// effector.add(endEffector);
		// forearm.add(effector);
		// arm.add(forearm);
		// arm.position.y = arm.position.y + 10;
		// scene.add(arm);


  }
function fillScene() {
		scene = new THREE.Scene();
		//scene.fog = new THREE.Fog(0x808080,2000,4000);
		var ambientLight = new THREE.AmbientLight(0x222222);
		var light = new THREE.DirectionalLight(0xFFFFFF,1.0);
		light.position.set(200, 400, 500);
		var light2 = new THREE.DirectionalLight(0xFFFFFF,1.0);
		light2.position.set(-500, 250, -200);
		scene.add(ambientLight);
		scene.add(light);
		scene.add(light2);
		var robotBaseMaterial = new THREE.MeshPhongMaterial({
				color: 0x6E23BB,
				specular: 0x6E23BB,
				shininess: 20
		});
		var robotForearmMaterial = new THREE.MeshPhongMaterial({
				color: 0xF4C154,
				specular: 0xF4C154,
				shininess: 100
		});
		var robotUpperArmMaterial = new THREE.MeshPhongMaterial({
				color: 0x95E4FB,
				specular: 0x95E4FB,
				shininess: 100
		});
		var robotBodyMaterial = new THREE.MeshPhongMaterial({
				color: 0x279933,
				specular: 0x279933,
				shininess: 100
		});


		var base = new THREE.Mesh(new THREE.CylinderGeometry(30,30,10,32),robotBaseMaterial);
		//base.rotation.x = 90 * Math.PI / 180;
		base.position.y =5;
		scene.add(base);
		forearm = new THREE.Object3D();
		var faLength = 100;
		createRobotExtender(forearm, faLength, robotForearmMaterial);
		var uaLength = 100;
		var eLength = 50;
		effector = new THREE.Object3D();
		createRobotExtender(effector, eLength, robotForearmMaterial);
		arm = new THREE.Object3D();

		createRobotCrane(arm, uaLength, robotUpperArmMaterial);
		endEffector = new THREE.Object3D();
		createEndEffector(endEffector, robotUpperArmMaterial);
		forearm.position.y = uaLength;
		effector.position.y = faLength;
		endEffector.position.y = eLength;
		effector.add(endEffector);
		forearm.add(effector);
		arm.add(forearm);
		//arm.position.y = arm.position.y + 10;
		scene.add(arm);

}
function createRobotExtender(part, length, material) {
		// var cylinder = new THREE.Mesh(new THREE.CylinderGeometry(22,22,6,32),material);
		// part.add(cylinder);
		var i;
		for (i = 0; i < 4; i++) {
				var box = new THREE.Mesh(new THREE.CubeGeometry(4,length,4),material);
				box.position.x = (i < 2) ? -8 : 8;
				box.position.y = length / 2;
				box.position.z = (i % 2) ? -8 : 8;
				part.add(box);
		}
		cylinder = new THREE.Mesh(new THREE.CylinderGeometry(15,15,40,32),material);
		cylinder.rotation.x = 90 * Math.PI / 180;
		cylinder.position.y = 0;
		part.add(cylinder);
}
function createRobotCrane(part, length, material) {
		var box = new THREE.Mesh(new THREE.CubeGeometry(18,length,18),material);
		box.position.y = length / 2;
		part.add(box);


	cylinder1 = new THREE.Mesh(new THREE.CylinderGeometry(15,15,40,32),material);
		cylinder1.rotation.x = 90 * Math.PI / 180;
		cylinder1.position.y = 0;
		part.add(cylinder1);
		// var sphere = new THREE.Mesh(new THREE.SphereGeometry(20,32,16),material);
		// sphere.position.y = length;
		// part.add(sphere);
}
function createRobotBody(part, length, material) {
		var cylinder = new THREE.Mesh(new THREE.CylinderGeometry(50,12,length / 2,18),material);
		cylinder.position.y = length / 4;
		part.add(cylinder);
		cylinder = new THREE.Mesh(new THREE.CylinderGeometry(12,50,length / 2,18),material);
		cylinder.position.y = 3 * length / 4;
		part.add(cylinder);
		var box = new THREE.Mesh(new THREE.CubeGeometry(12,length / 4,110),material);
		box.position.y = length / 2;
		part.add(box);
		//var sphere = new THREE.Mesh(new THREE.SphereGeometry(20,32,16),material);
		//sphere.position.y = length;6
		//part.add(sphere);
}
function createEndEffector(part, material){
		var cylinder = new THREE.Mesh(new THREE.CylinderGeometry(15,15,10,32),material);
		cylinder.position.y = 0;
		part.add(cylinder);
		var cone = new THREE.Mesh(new THREE.ConeGeometry( 15, 30, 32 ),new THREE.MeshPhongMaterial({
				color: 0x6E23BB,
				specular: 0x6E23BB,
				shininess: 20
		}));
		cone.position.y = 15;
		part.add(cone);
}
function init() {


		container = document.getElementById( 'container' );
		var canvasWidth = 846;
		var canvasHeight = 494;
		var canvasRatio = canvasWidth / canvasHeight;
		renderer = new THREE.WebGLRenderer({
				antialias: true,
				alpha: true
		});
		renderer.gammaInput = true;
		renderer.gammaOutput = true;
		renderer.setSize(canvasWidth, canvasHeight);
		renderer.setClearColor(0x000000, 0 );
		camera = new THREE.PerspectiveCamera(38,canvasRatio,1,10000);
		camera.position.set(-510, 240, 100);
		cameraControls = new THREE.OrbitControls(camera,renderer.domElement);
		cameraControls.target.set(0, 120, 0);
		camera.position.set(-102, 177, 20);
		cameraControls.target.set(-13, 60, 2);
		//var tween = new TWEEN.Tween(rotation).to(10* Math.PI / 180 , 2000);
		fillScene();
}
function addToDOM() {
		var container = document.getElementById('container');
		var canvas = container.getElementsByTagName('canvas');
		if (canvas.length > 0) {
				container.removeChild(canvas[0]);
		}
		container.appendChild(renderer.domElement);
}
function drawHelpers() {
		if (ground) {
				Coordinates.drawGround({
						size: 10000
				});
		}
		if (gridX) {
				Coordinates.drawGrid({
						size: 10000,
						scale: 0.01
				});
		}
		if (gridY) {
				Coordinates.drawGrid({
						size: 10000,
						scale: 0.01,
						orientation: "y"
				});
		}
		if (gridZ) {
				Coordinates.drawGrid({
						size: 10000,
						scale: 0.01,
						orientation: "z"
				});
		}
		if (axes) {
				Coordinates.drawAllAxes({
						axisLength: 200,
						axisRadius: 1,
						axisTess: 50
				});
		}
}
function animate() {
		window.requestAnimationFrame(animate);
		render();
}
function render() {
		var delta = clock.getDelta();
		cameraControls.update(delta);
		if (effectController.newGridX !== gridX || effectController.newGridY !== gridY || effectController.newGridZ !== gridZ || effectController.newGround !== ground || effectController.newAxes !== axes) {
				gridX = effectController.newGridX;
				gridY = effectController.newGridY;
				gridZ = effectController.newGridZ;
				ground = effectController.newGround;
				axes = effectController.newAxes;
				fillScene();
				drawHelpers();
		}


		// arm.rotation.y = effectController.uy * Math.PI / 180;
		// // if(arm.rotation.y != effectController.uy){
		// // 		console.log(arm.rotation.y);
		// // }
		// arm.rotation.z = effectController.uz * Math.PI / 180;
		// effector.rotation.z = effectController.ez * Math.PI / 180;
		// forearm.rotation.z = effectController.fz * Math.PI / 180;
    //console.log(new THREE.Vector3().setFromMatricPosition(endEffector));
		renderer.render(scene, camera);
}

// function rotateAngle(part, axis, destAngle){
// 	var destAngleDeg = destAngle* Math.PI / 180;
//
// 	//console.log(destAngle);
// 	// console.log(arm.rotation.y);
// 	// console.log(destAngle);
// 	if(arm.rotation.y != destAngleDeg){
// 		if(arm.rotation.y < destAngleDeg){
// 			arm.rotation.y = arm.rotation.y + 0.001;
// 		}
// 		else if (arm.rotation.y > destAngleDeg) {
// 			arm.rotation.y = arm.rotation.y - 0.001;
// 		}
// 	}
//
//
// }
function remakeGUI(armconfig){
  gui.destroy();
  effectController = {
      newGridX: gridX,
      newGridY: gridY,
      newGridZ: gridZ,
      newGround: ground,
      newAxes: axes
  };

  gui = new dat.GUI();
  var h = gui.addFolder("Grid display");
  h.add(effectController, "newGridX").name("Show XZ grid");
  h.add(effectController, "newGridY").name("Show YZ grid");
  h.add(effectController, "newGridZ").name("Show XY grid");
  h.add(effectController, "newGround").name("Show ground");
  h.add(effectController, "newAxes").name("Show axes");
  h = gui.addFolder("Arm angles");
  armconfig.forEach(function(object){
      object["angle"] = 0.0;
    h.add(object, "angle", -180.0, 180.0, 0.025).name(object["id"]).onChange(function(angle){moveArm(object, angle)});
  //  h.add(object, "id").name("").onchange()
  console.log(object);
  });
  //console.log(armconfig);

}

function moveArm(armObject, angle){
if(object["z"]){
  //move in z
}
elseif(object["y"]){#
  //move in y
}
elseif(object["x"]){
  //move in x
}
  console.log(armObject);
}

function setupGui() {
    effectController = {
        newGridX: gridX,
        newGridY: gridY,
        newGridZ: gridZ,
        newGround: ground,
        newAxes: axes
        // uy: 0.0,
        // uz: 0.0,
        // ez: 0.0,
        // fz: 0.0
    };


    gui = new dat.GUI();
    var h = gui.addFolder("Grid display");
    h.add(effectController, "newGridX").name("Show XZ grid");
    h.add(effectController, "newGridY").name("Show YZ grid");
    h.add(effectController, "newGridZ").name("Show XY grid");
    h.add(effectController, "newGround").name("Show ground");
    h.add(effectController, "newAxes").name("Show axes");
    h = gui.addFolder("Arm angles");


    // h.add(effectController, "uy", -180.0, 180.0, 0.025).name("Upper arm y").onChange(function(uy){var vector = new THREE.Vector3(); vector.setFromMatrixPosition(endEffector.matrixWorld); console.log(vector);});
    // h.add(effectController, "uz", -45.0, 45.0, 0.025).name("Upper arm z").onChange(function(uz){var vector = new THREE.Vector3(); vector.setFromMatrixPosition(endEffector.matrixWorld); console.log(vector);});
    // h.add(effectController, "fz", -120.0, 120.0, 0.025).name("Forearm z").onChange(function(fz){var vector = new THREE.Vector3(); vector.setFromMatrixPosition(endEffector.matrixWorld); console.log(vector);});
    // h.add(effectController, "ez", -120.0, 120.0, 0.025).name("Effector z").onChange(function(ez){var vector = new THREE.Vector3(); vector.setFromMatrixPosition(endEffector.matrixWorld); console.log(vector);});

}

try {
		init();
		fillScene();
		drawHelpers();
		addToDOM();
		setupGui();
		animate();
} catch (e) {
		var errorReport = "Your program encountered an unrecoverable error, can not draw on canvas. Error was:<br/><br/>";
		$('#container').append(errorReport + e);
}



		</script>
</head>
<body>
>

</body>
</html>
